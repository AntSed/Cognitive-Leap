<!--
  File: app/components/SceneViewer.vue
  Final version with an SVG icon button for model switching and externalized styles.
-->
<template>
  <div class="sv-wrapper">
    <!-- UI Elements -->
    <div class="sv-controls">
        <button @click="switchModel" class="sv-button" aria-label="Switch Model">
            <!-- SVG Icon for switching models -->
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF">
                <path d="M0 0h24v24H0V0z" fill="none"/>
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88C7.55 15.8 9.68 15 12 15s4.45.8 6.14 2.12C16.43 19.18 14.03 20 12 20z"/>
            </svg>
        </button>
    </div>
    <div ref="labelsContainerRef" class="sv-labels-container" @click="onLabelClick"></div>
    <canvas ref="canvasRef"></canvas>

    <!-- Modal -->
    <div v-if="isModalVisible" class="sv-modal-overlay" @click="closeModal">
      <div class="sv-modal-content" @click.stop>
        <button @click="closeModal" class="sv-modal-close">&times;</button>
        <h2 class="sv-modal-topic">{{ activeModalData.topic }}</h2>
        <p><strong>Subject:</strong> <span>{{ activeModalData.subject }}</span></p>
        <p><strong>Lesson ID:</strong> <span>{{ activeModalData.lesson_id }}</span></p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js'; // Import STLLoader

// --- CONFIGURATION ---
const CONFIG = {
  MAX_LABELS: 6,
  CAMERA_INITIAL_POSITION: [40, 0, 5], // Start from the side
  ROTATION_SENSITIVITY: 0.005,
  ZOOM_SENSITIVITY: 0.05,
  FONT_SIZE_BASE: 30,
  FONT_SIZE_FACTOR: 0.8,
  FONT_SIZE_MIN_THRESHOLD: 9,
  MODELS: [
    { 
      name: 'Stoya', 
      url: 'https://cdopmabluqeueagtsjlv.supabase.co/storage/v1/object/public/3d/Stoya.stl',
      scale: 0.75,
      position: [0, -13, -2],
      rotation: [-Math.PI / 2, 0, 0] // Rotate 90 degrees on X-axis to stand up
    },
    { 
      name: 'Lee Perry Smith', 
      url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/models/gltf/LeePerrySmith/LeePerrySmith.glb',
      scale: 8,
      position: [0, -16, 0],
      rotation: [0, 0, 0] // Default rotation
    }
  ]
};

// --- VUE REACTIVE STATE ---
const canvasRef = ref(null);
const labelsContainerRef = ref(null);
const isModalVisible = ref(false);
const activeModalData = ref({});
let threeApp = null;
const supabase = useSupabaseClient();

// --- MODAL LOGIC ---
const showModal = (data) => {
  if (!data || !data.lesson) return;
  activeModalData.value = {
    topic: data.lesson.topic_translations?.en || 'Untitled',
    subject: data.lesson.subject?.en || 'Not specified',
    lesson_id: data.lesson.id,
  };
  isModalVisible.value = true;
};
const closeModal = () => { isModalVisible.value = false; };

// --- UI EVENT HANDLERS ---
const onLabelClick = (event) => {
    if (event.target.classList.contains('sv-label')) {
        const globalId = parseInt(event.target.dataset.globalId, 10);
        if (!isNaN(globalId) && threeApp) {
            const data = threeApp.allInstancesData[globalId];
            if (data) showModal(data);
        }
    }
};

// New function to switch models
const switchModel = () => {
    if (threeApp) {
        threeApp.switchModel();
    }
};

// --- LIFECYCLE HOOKS ---
onMounted(async () => {
  try {
    if (process.server) return;
    const skinId = '38c24e69-24f9-4a7c-a003-84d298280c14';
    const { data: skinData, error } = await supabase.rpc('get_skin_layout_data', { p_skin_id: skinId });
    if (error) { console.error('Error loading skin layout data:', error); return; }
    if (!skinData || skinData.length === 0) { console.warn(`Warning: No data returned for skin ID '${skinId}'.`); return; }
    
    threeApp = new ThreeApp(canvasRef.value, labelsContainerRef.value, skinData, showModal, CONFIG, supabase);
    threeApp.init();
    threeApp.animate();
  } catch (e) { console.error(`An unexpected error occurred in onMounted: ${e.message}`); }
});

onUnmounted(() => { if (threeApp) { threeApp.destroy(); } });

// --- SHADERS ---
const vertexShader = `
    attribute float progress; varying vec3 vWorldPosition; varying vec3 vObjectCenterWorld; varying float vProgress; uniform vec3 boundingBoxMin; uniform vec3 boundingBoxMax; varying vec3 vBoundingBoxMin; varying vec3 vBoundingBoxMax;
    void main() { vProgress = progress; vBoundingBoxMin = boundingBoxMin; vBoundingBoxMax = boundingBoxMax; vWorldPosition = (modelMatrix * instanceMatrix * vec4(position, 1.0)).xyz; vObjectCenterWorld = (modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz; gl_Position = projectionMatrix * viewMatrix * vec4(vWorldPosition, 1.0); }
`;
const fragmentShader = `
    varying vec3 vWorldPosition; varying vec3 vObjectCenterWorld; varying float vProgress; varying vec3 vBoundingBoxMin; varying vec3 vBoundingBoxMax; uniform vec3 liquidColor; uniform vec3 glassColor; uniform vec3 upVector;
    void main() { float totalHeight = vBoundingBoxMax.y - vBoundingBoxMin.y; float fillOffset = (vProgress - 0.5) * totalHeight; vec3 fromCenterToPixel = vWorldPosition - vObjectCenterWorld; float heightInGravity = dot(fromCenterToPixel, upVector); if (heightInGravity < fillOffset) { gl_FragColor = vec4(liquidColor, 1.0); } else { gl_FragColor = vec4(glassColor, 0.3); } }
`;

// =================================================================================================
// --- CORE THREE.JS APPLICATION CLASS ---
// =================================================================================================
class ThreeApp {
    constructor(canvas, labelsContainer, skinData, showModalCallback, config, supabase) {
        this.canvas = canvas;
        this.wrapper = canvas.parentElement;
        this.labelsContainer = labelsContainer;
        this.skinData = skinData;
        this.showModal = showModalCallback;
        this.config = config;
        this.supabase = supabase;
        this.animationFrameId = null;

        // --- Model State ---
        this.currentModelIndex = 0;
        this.currentHeadModel = null;

        // --- Editor State ---
        this.isEditMode = false;
        this.draggedObject = null;
        this.dragPlane = new THREE.Plane();
        this.dragOffset = new THREE.Vector3();
    }

    init() {
        this.initScene();
        this.initModels();
        this.initLabels();
        this.initControls();
    }

    initScene() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, canvas: this.canvas, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(...this.config.CAMERA_INITIAL_POSITION);
        this.camera.lookAt(this.scene.position); // Ensure camera points to the center
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(5, 10, 15);
        this.scene.add(pointLight);
        this.mainGroup = new THREE.Group();
        this.scene.add(this.mainGroup);
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
    }

    initModels() {
        const geometries = { 'Sphere': new THREE.SphereGeometry(0.5, 16, 16), 'Box': new THREE.BoxGeometry(0.8, 0.8, 0.8), 'Tetrahedron': new THREE.TetrahedronGeometry(0.7), 'Octahedron': new THREE.OctahedronGeometry(0.6), 'Dodecahedron': new THREE.DodecahedronGeometry(0.5), 'Icosahedron': new THREE.IcosahedronGeometry(0.5, 0), 'Torus': new THREE.TorusGeometry(0.4, 0.15, 16, 100), 'TorusKnot': new THREE.TorusKnotGeometry(0.4, 0.1, 100, 16), 'Cylinder': new THREE.CylinderGeometry(0.4, 0.4, 0.8, 32), 'Cone': new THREE.ConeGeometry(0.4, 0.8, 32), 'Capsule': new THREE.CapsuleGeometry(0.3, 0.5, 4, 8), 'Ring': new THREE.RingGeometry(0.3, 0.5, 32), 'default': new THREE.IcosahedronGeometry(0.5, 0) };
        const lessonsByShape = this.skinData.reduce((acc, item) => { const shape = item.shape || 'default'; if (!acc[shape]) acc[shape] = []; acc[shape].push(item); return acc; }, {});
        this.instancedMeshes = [];
        this.allInstancesData = this.skinData;
        for (const shape in lessonsByShape) {
            const group = lessonsByShape[shape];
            const geometry = geometries[shape] || geometries['default'];
            geometry.computeBoundingBox();
            const shaderMaterial = new THREE.ShaderMaterial({ uniforms: { liquidColor: { value: new THREE.Color(0xffffff) }, glassColor: { value: new THREE.Color(0x87ceeb) }, boundingBoxMin: { value: geometry.boundingBox.min }, boundingBoxMax: { value: geometry.boundingBox.max }, upVector: { value: new THREE.Vector3(0, 1, 0) } }, vertexShader, fragmentShader, transparent: true });
            const mesh = new THREE.InstancedMesh(geometry, shaderMaterial, group.length);
            const progressAttribute = new Float32Array(group.length);
            group.forEach((item, index) => { progressAttribute[index] = Math.random(); });
            mesh.geometry.setAttribute('progress', new THREE.InstancedBufferAttribute(progressAttribute, 1));
            const dummy = new THREE.Object3D();
            group.forEach((item, index) => {
                dummy.position.set(item.coordinates.x, item.coordinates.y, item.coordinates.z);
                dummy.scale.set(item.scale || 1, item.scale || 1, item.scale || 1);
                dummy.updateMatrix();
                mesh.setMatrixAt(index, dummy.matrix);
                mesh.userData[index] = this.allInstancesData.indexOf(item);
            });
            mesh.instanceMatrix.needsUpdate = true;
            this.instancedMeshes.push(mesh);
            this.mainGroup.add(mesh);
        }
        // Load the initial model.
        this.loadHeadModel(this.config.MODELS[this.currentModelIndex]);
    }

    loadHeadModel(modelInfo) {
        const material = new THREE.MeshPhysicalMaterial({
            color: 0x87ceeb, transparent: true, opacity: 0.3, roughness: 0.1, metalness: 0.2, transmission: 0.9, ior: 1.5, side: THREE.DoubleSide, depthWrite: false
        });

        const onModelLoaded = (object) => {
            this.currentHeadModel = object;
            this.currentHeadModel.scale.setScalar(modelInfo.scale);
            this.currentHeadModel.position.set(...modelInfo.position);
            if (modelInfo.rotation) {
                this.currentHeadModel.rotation.set(...modelInfo.rotation);
            }
            this.currentHeadModel.traverse((child) => { if (child.isMesh) { child.material = material; } });
            this.mainGroup.add(this.currentHeadModel);
        };

        if (modelInfo.url.endsWith('.stl')) {
            const loader = new STLLoader();
            loader.load(modelInfo.url, (geometry) => {
                const mesh = new THREE.Mesh(geometry, material);
                onModelLoaded(mesh);
            });
        } else { // Assume GLB/GLTF
            const loader = new GLTFLoader();
            loader.load(modelInfo.url, (gltf) => {
                onModelLoaded(gltf.scene);
            });
        }
    }

    switchModel() {
        if (this.currentHeadModel) {
            this.mainGroup.remove(this.currentHeadModel);
        }
        this.currentModelIndex = (this.currentModelIndex + 1) % this.config.MODELS.length;
        this.loadHeadModel(this.config.MODELS[this.currentModelIndex]);
    }
    
    initLabels() {
        this.labelPool = []; this.visibleLabels = new Map();
        for (let i = 0; i < this.config.MAX_LABELS; i++) { 
            const label = document.createElement('div'); label.className = 'sv-label'; this.labelsContainer.appendChild(label); this.labelPool.push({ element: label, inUse: false }); 
        }
    }

    initControls() {
        this.mouseMoved = false; this.touchMoved = false; this.previousMousePosition = { x: 0, y: 0 };
        this.initialPinchDistance = 0;
        this.onKeyDown = this.onKeyDown.bind(this); this.onMouseDown = this.onMouseDown.bind(this); this.onMouseMove = this.onMouseMove.bind(this); this.onMouseUp = this.onMouseUp.bind(this); this.onWheel = this.onWheel.bind(this); this.onWindowResize = this.onWindowResize.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this); this.onTouchMove = this.onTouchMove.bind(this); this.onTouchEnd = this.onTouchEnd.bind(this);
        
        this.canvas.addEventListener('mousedown', this.onMouseDown);
        this.canvas.addEventListener('touchstart', this.onTouchStart, { passive: false });
        this.canvas.addEventListener('touchmove', this.onTouchMove, { passive: false });
        this.canvas.addEventListener('touchend', this.onTouchEnd);

        window.addEventListener('keydown', this.onKeyDown);
        window.addEventListener('wheel', this.onWheel);
        window.addEventListener('resize', this.onWindowResize);
    }

    onKeyDown(e) {
        if (e.shiftKey && e.key.toLowerCase() === 'e') {
            this.isEditMode = !this.isEditMode;
            this.canvas.style.cursor = this.isEditMode ? 'grab' : 'default';
            if (this.wrapper) { this.wrapper.style.border = this.isEditMode ? '2px solid #00ff00' : 'none'; this.wrapper.style.boxSizing = 'border-box'; }
            console.log(`Edit mode: ${this.isEditMode ? 'ON' : 'OFF'}`);
        }
    }

    onMouseDown(e) {
        this.mouseMoved = false; this.previousMousePosition.x = e.clientX; this.previousMousePosition.y = e.clientY;
        if (this.isEditMode) { this.startDragging(e); }
        window.addEventListener('mousemove', this.onMouseMove); window.addEventListener('mouseup', this.onMouseUp);
    }

    onMouseMove(e) {
        this.mouseMoved = true;
        if (this.isEditMode && this.draggedObject) { 
            this.dragObject(e); 
        } else { 
            const deltaX = e.clientX - this.previousMousePosition.x;
            const deltaY = e.clientY - this.previousMousePosition.y;
            
            const rotXMatrix = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), -deltaX * this.config.ROTATION_SENSITIVITY);
            this.camera.position.applyMatrix4(rotXMatrix);

            const rotYMatrix = new THREE.Matrix4().makeRotationAxis(this.camera.position.clone().cross(new THREE.Vector3(0,1,0)).normalize(), -deltaY * this.config.ROTATION_SENSITIVITY);
            this.camera.position.applyMatrix4(rotYMatrix);

            this.camera.lookAt(this.scene.position);
        }
        this.previousMousePosition.x = e.clientX; this.previousMousePosition.y = e.clientY;
    }

    async onMouseUp(e) {
        window.removeEventListener('mousemove', this.onMouseMove); window.removeEventListener('mouseup', this.onMouseUp);
        if (this.isEditMode && this.draggedObject) { await this.stopDragging(); }
        if (!this.mouseMoved && !this.isEditMode) { this.handleClick(e); }
    }

    onWheel(e) {
        const zoomAmount = e.deltaY * this.config.ZOOM_SENSITIVITY;
        const currentDistance = this.camera.position.length();
        const newDistance = THREE.MathUtils.clamp(currentDistance + zoomAmount, 10, 60);
        this.camera.position.setLength(newDistance);
    }

    getTouchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    onTouchStart(e) {
        e.preventDefault();
        this.touchMoved = false;
        const touches = e.touches;
        if (touches.length === 1) {
            this.previousMousePosition.x = touches[0].clientX;
            this.previousMousePosition.y = touches[0].clientY;
        } else if (touches.length === 2) {
            this.initialPinchDistance = this.getTouchDistance(touches);
        }
    }

    onTouchMove(e) {
        e.preventDefault();
        this.touchMoved = true;
        const touches = e.touches;
        if (touches.length === 1) {
            const deltaX = touches[0].clientX - this.previousMousePosition.x;
            const deltaY = touches[0].clientY - this.previousMousePosition.y;
            
            const rotXMatrix = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), -deltaX * this.config.ROTATION_SENSITIVITY);
            this.camera.position.applyMatrix4(rotXMatrix);
            
            // --- ИСПРАВЛЕНИЕ ЗДЕСЬ: Возвращаем правильный знак для интуитивного управления ---
            const rotYMatrix = new THREE.Matrix4().makeRotationAxis(this.camera.position.clone().cross(new THREE.Vector3(0,1,0)).normalize(), deltaY * this.config.ROTATION_SENSITIVITY);
            this.camera.position.applyMatrix4(rotYMatrix);

            this.camera.lookAt(this.scene.position);
            
            this.previousMousePosition.x = touches[0].clientX;
            this.previousMousePosition.y = touches[0].clientY;
        } else if (touches.length === 2) {
            const newPinchDistance = this.getTouchDistance(touches);
            const deltaDistance = this.initialPinchDistance - newPinchDistance;
            
            const currentDistance = this.camera.position.length();
            const newCamDistance = THREE.MathUtils.clamp(currentDistance + deltaDistance * 0.1, 10, 60);
            this.camera.position.setLength(newCamDistance);
            
            this.initialPinchDistance = newPinchDistance;
        }
    }

    onTouchEnd(e) {
        e.preventDefault();
        if (!this.touchMoved && e.changedTouches.length === 1) {
            const touch = e.changedTouches[0];
            this.handleClick({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    onWindowResize() { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }

    handleClick(e) {
        if (this.isEditMode) return;
        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.instancedMeshes);
        if (intersects.length > 0) { const intersection = intersects[0]; const globalIndex = intersection.object.userData[intersection.instanceId]; const data = this.allInstancesData[globalIndex]; this.showModal(data); }
    }

    startDragging(e) {
        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.instancedMeshes);
        if (intersects.length > 0) {
            const intersection = intersects[0]; this.draggedObject = { mesh: intersection.object, instanceId: intersection.instanceId };
            const intersectionPoint = intersection.point; this.dragPlane.setFromNormalAndCoplanarPoint(this.camera.getWorldDirection(this.dragPlane.normal), intersectionPoint);
            const instanceMatrix = new THREE.Matrix4(); this.draggedObject.mesh.getMatrixAt(this.draggedObject.instanceId, instanceMatrix);
            const instancePosition = new THREE.Vector3().setFromMatrixPosition(instanceMatrix);
            const worldInstancePosition = instancePosition.clone().applyMatrix4(this.mainGroup.matrixWorld);
            this.dragOffset.copy(intersectionPoint).sub(worldInstancePosition); this.canvas.style.cursor = 'grabbing';
        }
    }

    dragObject(e) {
        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersectionPoint = new THREE.Vector3(); this.raycaster.ray.intersectPlane(this.dragPlane, intersectionPoint);
        const newWorldPosition = intersectionPoint.sub(this.dragOffset);
        const inverseGroupMatrix = this.mainGroup.matrixWorld.clone().invert();
        const newLocalPosition = newWorldPosition.clone().applyMatrix4(inverseGroupMatrix);
        const dummy = new THREE.Object3D(); this.draggedObject.mesh.getMatrixAt(this.draggedObject.instanceId, dummy.matrix);
        const scale = new THREE.Vector3(); const quaternion = new THREE.Quaternion();
        dummy.matrix.decompose(new THREE.Vector3(), quaternion, scale);
        dummy.matrix.compose(newLocalPosition, quaternion, scale);
        this.draggedObject.mesh.setMatrixAt(this.draggedObject.instanceId, dummy.matrix);
        this.draggedObject.mesh.instanceMatrix.needsUpdate = true;
    }

    async stopDragging() {
        const dummy = new THREE.Object3D(); this.draggedObject.mesh.getMatrixAt(this.draggedObject.instanceId, dummy.matrix);
        dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
        const newCoords = { x: dummy.position.x, y: dummy.position.y, z: dummy.position.z };
        const globalIndex = this.draggedObject.mesh.userData[this.draggedObject.instanceId];
        const lessonData = this.allInstancesData[globalIndex];
        console.log(`Saving new coordinates for layout ${lessonData.layout_id}:`, newCoords);
        const { data, error } = await this.supabase.from('skin_layouts').update({ coordinates: newCoords }).eq('id', lessonData.layout_id).select();
        if (error) { console.error("Error updating coordinates:", error); } 
        else { lessonData.coordinates = newCoords; console.log("Save successful! Response from DB:", data); }
        this.draggedObject = null; this.canvas.style.cursor = 'grab';
    }

    updateLabels() {
        if (!this.renderer || !this.labelsContainer) return;
        const tempVec = new THREE.Vector3(); const dummyMatrix = new THREE.Matrix4();
        const canvasRect = this.renderer.domElement.getBoundingClientRect();
        const allVisibleInstances = [];
        const viewMatrix = this.camera.matrixWorldInverse;
        this.instancedMeshes.forEach(mesh => {
            for(let i = 0; i < mesh.count; i++) {
                mesh.getMatrixAt(i, dummyMatrix); tempVec.setFromMatrixPosition(dummyMatrix); tempVec.applyMatrix4(this.mainGroup.matrixWorld);
                const pointInCameraSpace = tempVec.clone().applyMatrix4(viewMatrix);
                if (pointInCameraSpace.z > 0) { continue; }
                const projectedVec = tempVec.clone().project(this.camera);
                const distance = this.camera.position.distanceTo(tempVec);
                const fontSize = Math.max(8, this.config.FONT_SIZE_BASE - distance * this.config.FONT_SIZE_FACTOR);
                if (fontSize <= this.config.FONT_SIZE_MIN_THRESHOLD) continue;
                const data = this.allInstancesData[mesh.userData[i]];
                if (!data || !data.lesson || !data.lesson.subject) continue;
                allVisibleInstances.push({ globalId: mesh.userData[i], distance: distance, screenX: (projectedVec.x * 0.5 + 0.5) * canvasRect.width, screenY: (projectedVec.y * -0.5 + 0.5) * canvasRect.height, fontSize: fontSize });
            }
        });
        allVisibleInstances.sort((a, b) => a.distance - b.distance);
        const instancesToShow = allVisibleInstances.slice(0, this.config.MAX_LABELS);
        const currentVisibleIds = new Set(instancesToShow.map(inst => inst.globalId));
        for (const [id, labelObj] of this.visibleLabels.entries()) { if (!currentVisibleIds.has(id)) { labelObj.element.classList.remove('visible'); labelObj.inUse = false; this.visibleLabels.delete(id); } }
        instancesToShow.forEach(instance => {
            let labelObj = this.visibleLabels.get(instance.globalId);
            if (!labelObj) { labelObj = this.labelPool.find(p => !p.inUse); if (labelObj) { labelObj.inUse = true; this.visibleLabels.set(instance.globalId, labelObj); } }
            if (labelObj) { 
                const data = this.allInstancesData[instance.globalId]; 
                labelObj.element.dataset.globalId = this.allInstancesData.indexOf(data);
                labelObj.element.classList.add('visible'); 
                labelObj.element.textContent = `${data.lesson.subject?.en || '?'}: ${data.lesson.topic_translations?.en || ''}`; 
                labelObj.element.style.transform = `translate(-50%, 20px)`; 
                labelObj.element.style.left = `${instance.screenX}px`; 
                labelObj.element.style.top = `${instance.screenY}px`; 
                labelObj.element.style.fontSize = `${instance.fontSize}px`; 
            }
        });
    }

    animate() {
        this.animationFrameId = requestAnimationFrame(() => this.animate());
        this.updateLabels();
        this.renderer.render(this.scene, this.camera);
    }

    destroy() {
        if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); }
        if (this.wrapper) { this.wrapper.style.border = 'none'; this.wrapper.style.boxSizing = 'content-box'; }
        this.canvas.removeEventListener('mousedown', this.onMouseDown);
        this.canvas.removeEventListener('touchstart', this.onTouchStart);
        this.canvas.removeEventListener('touchmove', this.onTouchMove);
        this.canvas.removeEventListener('touchend', this.onTouchEnd);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('wheel', this.onWheel);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('keydown', this.onKeyDown);
        this.scene.traverse(object => {
            if (object.geometry) object.geometry.dispose();
            if (object.material) { if (Array.isArray(object.material)) { object.material.forEach(material => material.dispose()); } else { object.material.dispose(); } }
        });
        this.renderer.dispose();
    }
}
</script>